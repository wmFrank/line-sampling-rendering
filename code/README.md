# Hw7完成了所有的基础题和加分题
### 实验结果
#### 实验结果放在images文件夹下，包含task1、task2、task3三个子文件夹：
- task1（实现基础的path-tracing算法）
图片命名格式为： 分辨率 + 采样率 + 时间
//可以看出采样率的提升大大提升了渲染质量
- task2（实现多线程加速）
图片命名格式为： 分辨率 + 采样率 + 线程数 + 时间
//可以看出使用多线程确实可以大大提升渲染速度
- task3（实现微表面材质模型）
图片命名格式为： 分辨率 + 采样率 + 线程数 + 材质粗糙程度 + 时间
//采用微表面模型后可以很好地描述材质的粗糙程度，其渐变效果可以看得很清晰



### 实验思路
- 实现基础的path-tracing算法
这里主要的工作是理解代码框架中提供的各种path-tracing需要用到的函数，然后结合实验要求中提供的伪代码就可以实现出来。
- 实现多线程加速
使用多线程主要是合理分配任务，使得任务之间可以独立运行。我这里直接对需要渲染的像素点的数量进行均匀划分。比如这次实验是784\*784个像素点，如果是4线程，那么每个线程需要渲染196\*784个像素点。我实现了一个Job函数来描述一个线程需要做的工作，结合C++提供的std::thread来实现了多线程加速。
- 实现微表面材质模型
我添加了一种材质MICROFACET，实现这个模型也就是需要修改sample, eval, pdf这三个与材质有关的函数，其中sample和pdf我选择沿用DIFFUSE模型的相关函数。而eval则采用课上讲的模型，需要计算的有菲涅尔项（F）、阴影遮挡项(G)、法线分布项(D)，其中F直接采用框架中定义好的fresnel函数计算，G和D的计算有很多种，这里采用能反映材质粗糙程度的Cook-Torrance模型。最终的实验为了更加直观，我选择在Cornell Box中添加了球，然后效果还是很不错的。

